#define _GNU_SOURCE
#include "codegen.h"
#include "c_types.h"
#include "runtime.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// Create code generator
CodeGenerator* codegen_create(FILE* output, SymbolTable* symbol_table) {
    if (!output) return NULL;
    
    CodeGenerator* gen = malloc(sizeof(CodeGenerator));
    if (!gen) return NULL;
    
    gen->output = output;
    gen->symbol_table = symbol_table;
    gen->indent_level = 0;
    gen->in_function = false;
    gen->current_function_name = NULL;
    gen->temp_var_counter = 0;
    gen->label_counter = 0;
    gen->has_main_function = false;
    gen->needs_runtime = false;
    
    return gen;
}

// Destroy code generator
void codegen_destroy(CodeGenerator* gen) {
    if (!gen) return;
    
    free(gen->current_function_name);
    free(gen);
}

// Write indentation
void codegen_write_indent(CodeGenerator* gen) {
    if (!gen || !gen->output) return;
    
    for (int i = 0; i < gen->indent_level; i++) {
        fprintf(gen->output, "    ");
    }
}

// Increase indentation
void codegen_increase_indent(CodeGenerator* gen) {
    if (gen) gen->indent_level++;
}

// Decrease indentation
void codegen_decrease_indent(CodeGenerator* gen) {
    if (gen && gen->indent_level > 0) {
        gen->indent_level--;
    }
}

// Write formatted line with indentation
void codegen_write_line(CodeGenerator* gen, const char* format, ...) {
    if (!gen || !gen->output || !format) return;
    
    codegen_write_indent(gen);
    
    va_list args;
    va_start(args, format);
    vfprintf(gen->output, format, args);
    va_end(args);
    
    fprintf(gen->output, "\n");
}

// Write formatted text without indentation
void codegen_write(CodeGenerator* gen, const char* format, ...) {
    if (!gen || !gen->output || !format) return;
    
    va_list args;
    va_start(args, format);
    vfprintf(gen->output, format, args);
    va_end(args);
}

// Generate temporary variable name
char* codegen_generate_temp_var(CodeGenerator* gen) {
    if (!gen) return NULL;
    
    char* temp_var = malloc(32);
    if (!temp_var) return NULL;
    
    snprintf(temp_var, 32, "_temp_%d", gen->temp_var_counter++);
    return temp_var;
}

// Generate unique label
char* codegen_generate_label(CodeGenerator* gen) {
    if (!gen) return NULL;
    
    char* label = malloc(32);
    if (!label) return NULL;
    
    snprintf(label, 32, "_label_%d", gen->label_counter++);
    return label;
}

// Convert result to string
const char* codegen_result_to_string(CodegenResult result) {
    switch (result) {
        case CODEGEN_SUCCESS: return "Success";
        case CODEGEN_ERROR_FILE_IO: return "File I/O error";
        case CODEGEN_ERROR_INVALID_AST: return "Invalid AST";
        case CODEGEN_ERROR_UNSUPPORTED_FEATURE: return "Unsupported feature";
        case CODEGEN_ERROR_MEMORY_ALLOCATION: return "Memory allocation error";
        default: return "Unknown error";
    }
}

// Main code generation entry point
CodegenResult codegen_generate(CodeGenerator* gen, ASTNode* ast) {
    if (!gen || !ast) return CODEGEN_ERROR_INVALID_AST;
    
    printf("Starting code generation...\n");
    
    // Generate C code header
    CodegenResult result = codegen_generate_includes(gen);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate type definitions if needed
    result = codegen_generate_type_definitions(gen);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate the program
    result = codegen_generate_program(gen, ast);
    if (result != CODEGEN_SUCCESS) return result;
    
    printf("âœ“ Code generation completed successfully!\n");
    return CODEGEN_SUCCESS;
}

// Generate includes
CodegenResult codegen_generate_includes(CodeGenerator* gen) {
    if (!gen) return CODEGEN_ERROR_INVALID_AST;
    
    codegen_write_line(gen, "// Generated by Echo Language Compiler");
    codegen_write_line(gen, "// Do not edit this file manually");
    codegen_write_line(gen, "");
    
    // Standard includes
    codegen_write_line(gen, "#include <stdio.h>");
    codegen_write_line(gen, "#include <stdlib.h>");
    codegen_write_line(gen, "#include <stdbool.h>");
    codegen_write_line(gen, "#include <stdint.h>");
    codegen_write_line(gen, "#include <string.h>");
    
    // Runtime include if needed
    if (gen->needs_runtime) {
        codegen_write_line(gen, "#include \"echo_runtime.h\"");
    }
    
    codegen_write_line(gen, "");
    
    return CODEGEN_SUCCESS;
}

// Generate type definitions
CodegenResult codegen_generate_type_definitions(CodeGenerator* gen) {
    if (!gen) return CODEGEN_ERROR_INVALID_AST;
    
    // For now, just add a comment
    codegen_write_line(gen, "// Type definitions");
    codegen_write_line(gen, "");
    
    return CODEGEN_SUCCESS;
}

// Generate program
CodegenResult codegen_generate_program(CodeGenerator* gen, ASTNode* program) {
    if (!gen || !program || program->type != AST_PROGRAM) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // First pass: generate function declarations
    CodegenResult result = codegen_generate_function_declarations(gen, program);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write_line(gen, "");
    
    // Second pass: generate function implementations
    for (int i = 0; i < program->child_count; i++) {
        ASTNode* child = program->children[i];
        
        if (child->type == AST_FUNCTION) {
            result = codegen_generate_function(gen, child);
            if (result != CODEGEN_SUCCESS) return result;
            codegen_write_line(gen, "");
        }
    }
    
    return CODEGEN_SUCCESS;
}

// Generate function declarations
CodegenResult codegen_generate_function_declarations(CodeGenerator* gen, ASTNode* program) {
    if (!gen || !program) return CODEGEN_ERROR_INVALID_AST;
    
    codegen_write_line(gen, "// Function declarations");
    
    for (int i = 0; i < program->child_count; i++) {
        ASTNode* child = program->children[i];
        
        if (child->type == AST_FUNCTION) {
            CodegenResult result = codegen_generate_function_signature(gen, child);
            if (result != CODEGEN_SUCCESS) return result;
            codegen_write(gen, ";\n");
            
            // Check if this is main function
            if (child->value && strcmp(child->value, "main") == 0) {
                gen->has_main_function = true;
            }
        }
    }
    
    return CODEGEN_SUCCESS;
}

// Generate function signature
CodegenResult codegen_generate_function_signature(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function || function->type != AST_FUNCTION) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Find return type
    const char* return_type = "void";
    ASTNode* return_type_node = NULL;
    
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_TYPE) {
            return_type_node = function->children[i];
            break;
        }
    }
    
    if (return_type_node && return_type_node->value) {
        return_type = codegen_echo_type_to_c_type(return_type_node->value);
    }
    
    // Write function signature
    codegen_write(gen, "%s %s(", return_type, function->value);
    
    // Find parameters
    ASTNode* params = NULL;
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_PARAMETER) {
            params = function->children[i];
            break;
        }
    }
    
    if (params && params->child_count > 0) {
        for (int i = 0; i < params->child_count; i++) {
            ASTNode* param = params->children[i];
            if (param->type == AST_PARAMETER) {
                // Find parameter type
                const char* param_type = "int";
                if (param->child_count > 0 && param->children[0]->type == AST_TYPE) {
                    param_type = codegen_echo_type_to_c_type(param->children[0]->value);
                }
                
                codegen_write(gen, "%s %s", param_type, param->value);
                
                if (i < params->child_count - 1) {
                    codegen_write(gen, ", ");
                }
            }
        }
    } else {
        codegen_write(gen, "void");
    }
    
    codegen_write(gen, ")");
    
    return CODEGEN_SUCCESS;
}

// Basic type conversion (will be expanded in c_types.c)
const char* codegen_echo_type_to_c_type(const char* echo_type) {
    if (!echo_type) return "void";
    
    if (strcmp(echo_type, "i32") == 0) return "int32_t";
    if (strcmp(echo_type, "i64") == 0) return "int64_t";
    if (strcmp(echo_type, "f32") == 0) return "float";
    if (strcmp(echo_type, "f64") == 0) return "double";
    if (strcmp(echo_type, "bool") == 0) return "bool";
    if (strcmp(echo_type, "string") == 0) return "char*";
    if (strcmp(echo_type, "void") == 0) return "void";
    
    // Default fallback
    return echo_type;
}

// Check if type is optional
bool codegen_is_optional_type(const char* echo_type) {
    if (!echo_type) return false;
    
    size_t len = strlen(echo_type);
    return len > 0 && echo_type[len - 1] == '?';
}

// Check if type is pointer
bool codegen_is_pointer_type(const char* echo_type) {
    if (!echo_type) return false;
    
    size_t len = strlen(echo_type);
    return len > 0 && echo_type[len - 1] == '*';
}

// Check if type is smart pointer
bool codegen_is_smart_pointer_type(const char* echo_type) {
    if (!echo_type) return false;
    
    return strstr(echo_type, "unique<") != NULL || 
           strstr(echo_type, "shared<") != NULL;
}

// Placeholder implementations for remaining functions
CodegenResult codegen_generate_function(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function || function->type != AST_FUNCTION) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Set current function context
    gen->in_function = true;
    free(gen->current_function_name);
    gen->current_function_name = strdup(function->value);
    
    // Generate function signature
    CodegenResult result = codegen_generate_function_signature(gen, function);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write(gen, " {\n");
    codegen_increase_indent(gen);
    
    // Generate function body
    result = codegen_generate_function_body(gen, function);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_decrease_indent(gen);
    codegen_write_line(gen, "}");
    
    // Reset function context
    gen->in_function = false;
    free(gen->current_function_name);
    gen->current_function_name = NULL;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_function_body(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function) return CODEGEN_ERROR_INVALID_AST;
    
    // Find the function body (block)
    ASTNode* body = NULL;
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_BLOCK) {
            body = function->children[i];
            break;
        }
    }
    
    if (!body) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    return codegen_generate_block(gen, body);
}

CodegenResult codegen_generate_statement(CodeGenerator* gen, ASTNode* stmt) {
    if (!gen || !stmt) return CODEGEN_ERROR_INVALID_AST;
    
    switch (stmt->type) {
        case AST_VARIABLE_DECL:
            return codegen_generate_variable_decl(gen, stmt);
            
        case AST_RETURN:
            return codegen_generate_return(gen, stmt);
            
        case AST_EXPRESSION_STMT:
            if (stmt->child_count > 0) {
                CodegenResult result = codegen_generate_expression(gen, stmt->children[0]);
                if (result != CODEGEN_SUCCESS) return result;
                codegen_write(gen, ";\n");
                return CODEGEN_SUCCESS;
            }
            return CODEGEN_SUCCESS;
            
        case AST_IF:
            return codegen_generate_if(gen, stmt);
            
        case AST_FOR:
            return codegen_generate_for(gen, stmt);
            
        case AST_WHILE:
            return codegen_generate_while(gen, stmt);
            
        case AST_BLOCK:
            return codegen_generate_block(gen, stmt);
            
        default:
            // Try to generate as expression
            return codegen_generate_expression(gen, stmt);
    }
}

CodegenResult codegen_generate_block(CodeGenerator* gen, ASTNode* block) {
    if (!gen || !block || block->type != AST_BLOCK) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate each statement in the block
    for (int i = 0; i < block->child_count; i++) {
        CodegenResult result = codegen_generate_statement(gen, block->children[i]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_variable_decl(CodeGenerator* gen, ASTNode* var_decl) {
    if (!gen || !var_decl || var_decl->type != AST_VARIABLE_DECL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Get type
    const char* c_type = "int";
    if (var_decl->child_count > 0 && var_decl->children[0]->type == AST_TYPE) {
        c_type = codegen_echo_type_to_c_type(var_decl->children[0]->value);
    }
    
    // Write variable declaration with indentation
    codegen_write_indent(gen);
    codegen_write(gen, "%s %s", c_type, var_decl->value);
    
    // Handle initialization if present
    if (var_decl->child_count > 1) {
        codegen_write(gen, " = ");
        CodegenResult result = codegen_generate_expression(gen, var_decl->children[1]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write(gen, ";\n");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_return(CodeGenerator* gen, ASTNode* return_stmt) {
    if (!gen || !return_stmt || return_stmt->type != AST_RETURN) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    codegen_write_indent(gen);
    codegen_write(gen, "return");
    
    // Handle return value if present
    if (return_stmt->child_count > 0) {
        codegen_write(gen, " ");
        CodegenResult result = codegen_generate_expression(gen, return_stmt->children[0]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write(gen, ";\n");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_if(CodeGenerator* gen, ASTNode* if_stmt) {
    // TODO: Implement if statement generation
    (void)gen;
    (void)if_stmt;
    return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
}

CodegenResult codegen_generate_for(CodeGenerator* gen, ASTNode* for_stmt) {
    // TODO: Implement for loop generation
    (void)gen;
    (void)for_stmt;
    return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
}

CodegenResult codegen_generate_while(CodeGenerator* gen, ASTNode* while_stmt) {
    // TODO: Implement while loop generation
    (void)gen;
    (void)while_stmt;
    return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
}

CodegenResult codegen_generate_expression(CodeGenerator* gen, ASTNode* expr) {
    if (!gen || !expr) return CODEGEN_ERROR_INVALID_AST;
    
    switch (expr->type) {
        case AST_LITERAL:
            return codegen_generate_literal(gen, expr);
            
        case AST_IDENTIFIER:
            return codegen_generate_identifier(gen, expr);
            
        case AST_BINARY_OP:
            return codegen_generate_binary_op(gen, expr);
            
        case AST_UNARY_OP:
            return codegen_generate_unary_op(gen, expr);
            
        case AST_CALL:
            return codegen_generate_call(gen, expr);
            
        case AST_ASSIGNMENT:
            return codegen_generate_assignment(gen, expr);
            
        default:
            return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
    }
}

CodegenResult codegen_generate_binary_op(CodeGenerator* gen, ASTNode* binary_op) {
    if (!gen || !binary_op || binary_op->type != AST_BINARY_OP) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (binary_op->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate left operand
    CodegenResult result = codegen_generate_expression(gen, binary_op->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate operator
    codegen_write(gen, " %s ", binary_op->value);
    
    // Generate right operand
    result = codegen_generate_expression(gen, binary_op->children[1]);
    if (result != CODEGEN_SUCCESS) return result;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_unary_op(CodeGenerator* gen, ASTNode* unary_op) {
    if (!gen || !unary_op || unary_op->type != AST_UNARY_OP) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (unary_op->child_count < 1) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate operator
    codegen_write(gen, "%s", unary_op->value);
    
    // Generate operand
    return codegen_generate_expression(gen, unary_op->children[0]);
}

CodegenResult codegen_generate_call(CodeGenerator* gen, ASTNode* call) {
    if (!gen || !call || call->type != AST_CALL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (call->child_count < 1) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate function name
    CodegenResult result = codegen_generate_expression(gen, call->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write(gen, "(");
    
    // Generate arguments
    for (int i = 1; i < call->child_count; i++) {
        result = codegen_generate_expression(gen, call->children[i]);
        if (result != CODEGEN_SUCCESS) return result;
        
        if (i < call->child_count - 1) {
            codegen_write(gen, ", ");
        }
    }
    
    codegen_write(gen, ")");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_identifier(CodeGenerator* gen, ASTNode* identifier) {
    if (!gen || !identifier || identifier->type != AST_IDENTIFIER) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    codegen_write(gen, "%s", identifier->value);
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_literal(CodeGenerator* gen, ASTNode* literal) {
    if (!gen || !literal || literal->type != AST_LITERAL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (!literal->value) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate literal based on its type
    if (literal->data_type) {
        if (strcmp(literal->data_type, "string") == 0) {
            codegen_write(gen, "\"%s\"", literal->value);
        } else if (strcmp(literal->data_type, "char") == 0) {
            codegen_write(gen, "'%s'", literal->value);
        } else {
            // Integer, float, boolean literals
            codegen_write(gen, "%s", literal->value);
        }
    } else {
        // Default: assume it's a number or identifier
        codegen_write(gen, "%s", literal->value);
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_assignment(CodeGenerator* gen, ASTNode* assignment) {
    if (!gen || !assignment || assignment->type != AST_ASSIGNMENT) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (assignment->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate left side (lvalue)
    CodegenResult result = codegen_generate_expression(gen, assignment->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate assignment operator
    codegen_write(gen, " = ");
    
    // Generate right side (rvalue)
    result = codegen_generate_expression(gen, assignment->children[1]);
    if (result != CODEGEN_SUCCESS) return result;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_runtime_support(CodeGenerator* gen) {
    // TODO: Implement runtime support generation
    (void)gen;
    return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
}

bool codegen_needs_optional_support(ASTNode* ast) {
    // TODO: Implement optional support detection
    (void)ast;
    return false;
}

bool codegen_needs_smart_pointer_support(ASTNode* ast) {
    // TODO: Implement smart pointer support detection
    (void)ast;
    return false;
} 
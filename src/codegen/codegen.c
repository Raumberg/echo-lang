#define _GNU_SOURCE
#include "codegen.h"
#include "c_types.h"
#include "runtime.h"
#include "../semantic/type_inference.h"
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

// Create code generator
CodeGenerator* codegen_create(FILE* output, SymbolTable* symbol_table) {
    return codegen_create_with_inference(output, symbol_table, NULL);
}

// Create code generator with type inference context
CodeGenerator* codegen_create_with_inference(FILE* output, SymbolTable* symbol_table, 
                                           struct TypeInferenceContext* type_inference) {
    if (!output) return NULL;
    
    CodeGenerator* gen = malloc(sizeof(CodeGenerator));
    if (!gen) return NULL;
    
    gen->output = output;
    gen->symbol_table = symbol_table;
    gen->type_inference = type_inference;
    gen->indent_level = 0;
    gen->in_function = false;
    gen->current_function_name = NULL;
    gen->current_generic_instantiation = NULL;
    gen->temp_var_counter = 0;
    gen->label_counter = 0;
    gen->has_main_function = false;
    gen->needs_runtime = false;
    
    return gen;
}

// Destroy code generator
void codegen_destroy(CodeGenerator* gen) {
    if (!gen) return;
    
    free(gen->current_function_name);
    free(gen);
}

// Write indentation
void codegen_write_indent(CodeGenerator* gen) {
    if (!gen || !gen->output) return;
    
    for (int i = 0; i < gen->indent_level; i++) {
        fprintf(gen->output, "    ");
    }
}

// Increase indentation
void codegen_increase_indent(CodeGenerator* gen) {
    if (gen) gen->indent_level++;
}

// Decrease indentation
void codegen_decrease_indent(CodeGenerator* gen) {
    if (gen && gen->indent_level > 0) {
        gen->indent_level--;
    }
}

// Write formatted line with indentation
void codegen_write_line(CodeGenerator* gen, const char* format, ...) {
    if (!gen || !gen->output || !format) return;
    
    codegen_write_indent(gen);
    
    va_list args;
    va_start(args, format);
    vfprintf(gen->output, format, args);
    va_end(args);
    
    fprintf(gen->output, "\n");
}

// Write formatted text without indentation
void codegen_write(CodeGenerator* gen, const char* format, ...) {
    if (!gen || !gen->output || !format) return;
    
    va_list args;
    va_start(args, format);
    vfprintf(gen->output, format, args);
    va_end(args);
}

// Generate temporary variable name
char* codegen_generate_temp_var(CodeGenerator* gen) {
    if (!gen) return NULL;
    
    char* temp_var = malloc(32);
    if (!temp_var) return NULL;
    
    snprintf(temp_var, 32, "_temp_%d", gen->temp_var_counter++);
    return temp_var;
}

// Generate unique label
char* codegen_generate_label(CodeGenerator* gen) {
    if (!gen) return NULL;
    
    char* label = malloc(32);
    if (!label) return NULL;
    
    snprintf(label, 32, "_label_%d", gen->label_counter++);
    return label;
}

// Convert result to string
const char* codegen_result_to_string(CodegenResult result) {
    switch (result) {
        case CODEGEN_SUCCESS: return "Success";
        case CODEGEN_ERROR_FILE_IO: return "File I/O error";
        case CODEGEN_ERROR_INVALID_AST: return "Invalid AST";
        case CODEGEN_ERROR_UNSUPPORTED_FEATURE: return "Unsupported feature";
        case CODEGEN_ERROR_MEMORY_ALLOCATION: return "Memory allocation error";
        default: return "Unknown error";
    }
}

// Main code generation entry point
CodegenResult codegen_generate(CodeGenerator* gen, ASTNode* ast) {
    if (!gen || !ast) return CODEGEN_ERROR_INVALID_AST;
    
    printf("Starting code generation...\n");
    
    // Generate C code header
    CodegenResult result = codegen_generate_includes(gen);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate type definitions if needed
    result = codegen_generate_type_definitions(gen);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate the program
    result = codegen_generate_program(gen, ast);
    if (result != CODEGEN_SUCCESS) return result;
    
    printf("✓ Code generation completed successfully!\n");
    return CODEGEN_SUCCESS;
}

// Generate includes
CodegenResult codegen_generate_includes(CodeGenerator* gen) {
    if (!gen) return CODEGEN_ERROR_INVALID_AST;
    
    codegen_write_line(gen, "// Generated by Echo Language Compiler");
    codegen_write_line(gen, "// Do not edit this file manually");
    codegen_write_line(gen, "");
    
    // Standard includes
    codegen_write_line(gen, "#include <stdio.h>");
    codegen_write_line(gen, "#include <stdlib.h>");
    codegen_write_line(gen, "#include <stdbool.h>");
    codegen_write_line(gen, "#include <stdint.h>");
    codegen_write_line(gen, "#include <string.h>");
    
    // Always include Echo runtime
    codegen_write_line(gen, "#include \"echo_runtime.h\"");
    
    codegen_write_line(gen, "");
    
    return CODEGEN_SUCCESS;
}

// Generate type definitions
CodegenResult codegen_generate_type_definitions(CodeGenerator* gen) {
    if (!gen) return CODEGEN_ERROR_INVALID_AST;
    
    // For now, just add a comment
    codegen_write_line(gen, "// Type definitions");
    codegen_write_line(gen, "");
    
    return CODEGEN_SUCCESS;
}

// Generate program
CodegenResult codegen_generate_program(CodeGenerator* gen, ASTNode* program) {
    if (!gen || !program || program->type != AST_PROGRAM) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // First pass: generate struct definitions
    for (int i = 0; i < program->child_count; i++) {
        ASTNode* child = program->children[i];
        
        if (child->type == AST_STRUCT) {
            CodegenResult result = codegen_generate_struct(gen, child);
            if (result != CODEGEN_SUCCESS) return result;
            codegen_write_line(gen, "");
        }
    }
    
    // Second pass: generate function declarations (including generic instantiations)
    CodegenResult result = codegen_generate_function_declarations(gen, program);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate generic instantiations declarations
    if (gen->type_inference) {
        result = codegen_generate_generic_instantiations(gen);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write_line(gen, "");
    
    // Third pass: generate function implementations (non-generic only)
    for (int i = 0; i < program->child_count; i++) {
        ASTNode* child = program->children[i];
        
        if (child->type == AST_FUNCTION) {
            result = codegen_generate_function(gen, child);
            if (result != CODEGEN_SUCCESS) return result;
            codegen_write_line(gen, "");
        }
    }
    
    // Fourth pass: generate generic instantiations implementations
    if (gen->type_inference) {
        result = codegen_generate_generic_instantiations_impl(gen);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    return CODEGEN_SUCCESS;
}

// Generate function declarations
CodegenResult codegen_generate_function_declarations(CodeGenerator* gen, ASTNode* program) {
    if (!gen || !program) return CODEGEN_ERROR_INVALID_AST;
    
    codegen_write_line(gen, "// Function declarations");
    
    for (int i = 0; i < program->child_count; i++) {
        ASTNode* child = program->children[i];
        
        if (child->type == AST_FUNCTION) {
            CodegenResult result = codegen_generate_function_signature(gen, child);
            if (result != CODEGEN_SUCCESS) return result;
            codegen_write(gen, ";\n");
            
            // Check if this is main function
            if (child->value && strcmp(child->value, "main") == 0) {
                gen->has_main_function = true;
            }
        }
    }
    
    return CODEGEN_SUCCESS;
}

// Generate function signature
CodegenResult codegen_generate_function_signature(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function || function->type != AST_FUNCTION) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Find return type
    const char* return_type = "void";
    ASTNode* return_type_node = NULL;
    
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_TYPE) {
            return_type_node = function->children[i];
            break;
        }
    }
    
    if (return_type_node && return_type_node->value) {
        return_type = codegen_echo_type_to_c_type(return_type_node->value);
    }
    
    // Write function signature
    codegen_write(gen, "%s %s(", return_type, function->value);
    
    // Find parameters
    ASTNode* params = NULL;
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_PARAMETER) {
            params = function->children[i];
            break;
        }
    }
    
    if (params && params->child_count > 0) {
        for (int i = 0; i < params->child_count; i++) {
            ASTNode* param = params->children[i];
            if (param->type == AST_PARAMETER) {
                // Find parameter type
                const char* param_type = "int";
                if (param->child_count > 0 && param->children[0]->type == AST_TYPE) {
                    param_type = codegen_echo_type_to_c_type(param->children[0]->value);
                }
                
                codegen_write(gen, "%s %s", param_type, param->value);
                
                if (i < params->child_count - 1) {
                    codegen_write(gen, ", ");
                }
            }
        }
    } else {
        codegen_write(gen, "void");
    }
    
    codegen_write(gen, ")");
    
    return CODEGEN_SUCCESS;
}

// Basic type conversion (will be expanded in c_types.c)
const char* codegen_echo_type_to_c_type(const char* echo_type) {
    if (!echo_type) return "void";
    
    // Basic types
    if (strcmp(echo_type, "i32") == 0) return "int32_t";
    if (strcmp(echo_type, "i64") == 0) return "int64_t";
    if (strcmp(echo_type, "f32") == 0) return "float";
    if (strcmp(echo_type, "f64") == 0) return "double";
    if (strcmp(echo_type, "bool") == 0) return "bool";
    if (strcmp(echo_type, "string") == 0) return "char*";
    if (strcmp(echo_type, "void") == 0) return "void";
    
    // Type inference types (as generated by inference system)
    if (strcmp(echo_type, "integer") == 0) return "int";
    if (strcmp(echo_type, "float") == 0) return "double";
    
    // Default fallback
    return echo_type;
}

// Check if type is optional
bool codegen_is_optional_type(const char* echo_type) {
    if (!echo_type) return false;
    
    size_t len = strlen(echo_type);
    return len > 0 && echo_type[len - 1] == '?';
}

// Check if type is pointer
bool codegen_is_pointer_type(const char* echo_type) {
    if (!echo_type) return false;
    
    size_t len = strlen(echo_type);
    return len > 0 && echo_type[len - 1] == '*';
}

// Check if type is smart pointer
bool codegen_is_smart_pointer_type(const char* echo_type) {
    if (!echo_type) return false;
    
    return strstr(echo_type, "unique<") != NULL || 
           strstr(echo_type, "shared<") != NULL;
}

// Placeholder implementations for remaining functions
CodegenResult codegen_generate_function(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function || function->type != AST_FUNCTION) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Set current function context
    gen->in_function = true;
    free(gen->current_function_name);
    gen->current_function_name = strdup(function->value);
    
    // Generate function signature
    CodegenResult result = codegen_generate_function_signature(gen, function);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write(gen, " {\n");
    codegen_increase_indent(gen);
    
    // Generate function body
    result = codegen_generate_function_body(gen, function);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_decrease_indent(gen);
    codegen_write_line(gen, "}");
    
    // Reset function context
    gen->in_function = false;
    free(gen->current_function_name);
    gen->current_function_name = NULL;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_function_body(CodeGenerator* gen, ASTNode* function) {
    if (!gen || !function) return CODEGEN_ERROR_INVALID_AST;
    
    // Find the function body (block)
    ASTNode* body = NULL;
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_BLOCK) {
            body = function->children[i];
            break;
        }
    }
    
    if (!body) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    return codegen_generate_block(gen, body);
}

CodegenResult codegen_generate_statement(CodeGenerator* gen, ASTNode* stmt) {
    if (!gen || !stmt) return CODEGEN_ERROR_INVALID_AST;
    
    switch (stmt->type) {
        case AST_VARIABLE_DECL:
            return codegen_generate_variable_decl(gen, stmt);
            
        case AST_RETURN:
            return codegen_generate_return(gen, stmt);
            
        case AST_EXPRESSION_STMT:
            if (stmt->child_count > 0) {
                codegen_write_indent(gen);
                CodegenResult result = codegen_generate_expression(gen, stmt->children[0]);
                if (result != CODEGEN_SUCCESS) return result;
                codegen_write(gen, ";\n");
                return CODEGEN_SUCCESS;
            }
            return CODEGEN_SUCCESS;
            
        case AST_IF:
            return codegen_generate_if(gen, stmt);
            
        case AST_FOR:
            return codegen_generate_for(gen, stmt);
            
        case AST_WHILE:
            return codegen_generate_while(gen, stmt);
            
        case AST_BLOCK:
            return codegen_generate_block(gen, stmt);
            
        default:
            // Try to generate as expression
            return codegen_generate_expression(gen, stmt);
    }
}

CodegenResult codegen_generate_block(CodeGenerator* gen, ASTNode* block) {
    if (!gen || !block || block->type != AST_BLOCK) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate each statement in the block
    for (int i = 0; i < block->child_count; i++) {
        CodegenResult result = codegen_generate_statement(gen, block->children[i]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    return CODEGEN_SUCCESS;
}

// ================== HELPER FUNCTIONS FOR GENERIC INSTANTIATIONS ==================

// Normalize type names for instantiation matching
static char* normalize_type_name(const char* type_name) {
    if (!type_name) return strdup("integer");
    
    // Map C-style types to Echo types
    if (strcmp(type_name, "i32") == 0) return strdup("integer");
    if (strcmp(type_name, "f64") == 0) return strdup("float");
    if (strcmp(type_name, "f32") == 0) return strdup("float");
    if (strcmp(type_name, "i64") == 0) return strdup("integer");
    
    // Return as-is for other types
    return strdup(type_name);
}

// Find parameter list in a function AST
static ASTNode* find_parameter_list(ASTNode* function) {
    if (!function) return NULL;
    
    for (int i = 0; i < function->child_count; i++) {
        if (function->children[i]->type == AST_PARAMETER) {
            return function->children[i];
        }
    }
    return NULL;
}

// Find parameter type by name in generic instantiation
static char* find_parameter_type_in_instantiation(GenericInstantiation* inst, const char* param_name) {
    if (!inst || !param_name) return NULL;
    
    ASTNode* params = find_parameter_list(inst->original_function);
    if (!params) return NULL;
    
    // Find which parameter matches the identifier
    for (int i = 0; i < params->child_count && i < inst->type_arg_count; i++) {
        ASTNode* param = params->children[i];
        if (param->type == AST_PARAMETER && param->value &&
            strcmp(param->value, param_name) == 0) {
            // Found matching parameter - return its concrete type
            return strdup(inst->type_arguments[i]);
        }
    }
    return NULL;
}

// Infer auto variable type in generic instantiation context
static char* infer_auto_type_in_generic_context(GenericInstantiation* inst, ASTNode* init_expr, const char* var_name) {
    if (!inst || !init_expr) return NULL;
    
    char* inferred_type = NULL;
    
    // Case 1: Direct parameter reference (auto x = param)
    if (init_expr->type == AST_IDENTIFIER) {
        inferred_type = find_parameter_type_in_instantiation(inst, init_expr->value);
        if (inferred_type) {
            printf("✓ Using concrete type '%s' for auto variable '%s' in generic instantiation\n", 
                   inferred_type, var_name);
        }
    }
    // Case 2: Binary operations
    else if (init_expr->type == AST_BINARY_OP && init_expr->child_count >= 2) {
        ASTNode* left = init_expr->children[0];
        ASTNode* right = init_expr->children[1];
        
        // If both operands are the same parameter, use that parameter's type
        if (left->type == AST_IDENTIFIER && right->type == AST_IDENTIFIER &&
            left->value && right->value && strcmp(left->value, right->value) == 0) {
            
            inferred_type = find_parameter_type_in_instantiation(inst, left->value);
            if (inferred_type) {
                printf("✓ Using concrete type '%s' for auto variable '%s' from binary op in generic instantiation\n", 
                       inferred_type, var_name);
            }
        }
        // If left operand is a parameter, use its type
        else if (left->type == AST_IDENTIFIER) {
            inferred_type = find_parameter_type_in_instantiation(inst, left->value);
            if (inferred_type) {
                printf("✓ Using concrete type '%s' for auto variable '%s' from left operand in generic instantiation\n", 
                       inferred_type, var_name);
            } else {
                // If not a parameter, assume it's another auto variable with same type as first parameter
                if (inst->type_arg_count > 0) {
                    inferred_type = strdup(inst->type_arguments[0]);
                    printf("✓ Using concrete type '%s' for auto variable '%s' from auto variable operand in generic instantiation\n", 
                           inferred_type, var_name);
                }
            }
        }
    }
    
    return inferred_type;
}

// ================== END HELPER FUNCTIONS ==================

CodegenResult codegen_generate_variable_decl(CodeGenerator* gen, ASTNode* var_decl) {
    if (!gen || !var_decl || var_decl->type != AST_VARIABLE_DECL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Get type
    const char* c_type = "int";
    if (var_decl->child_count > 0) {
        ASTNode* type_node = var_decl->children[0];
        
        if (type_node->type == AST_AUTO_TYPE) {
            // For auto type, infer from initialization expression
            if (var_decl->child_count > 1 && gen->type_inference) {
                char* inferred_type = NULL;
                
                // If we're in a generic instantiation context, use specialized logic
                if (gen->current_generic_instantiation) {
                    inferred_type = infer_auto_type_in_generic_context(
                        gen->current_generic_instantiation, var_decl->children[1], var_decl->value);
                }
                
                // If we couldn't infer from generic context or we're not in generic context,
                // fall back to regular type inference
                if (!inferred_type) {
                    inferred_type = type_inference_infer_expression_type(
                        gen->type_inference, var_decl->children[1]);
                }
                
                if (inferred_type) {
                    c_type = codegen_echo_type_to_c_type(inferred_type);
                    free(inferred_type);
                } else {
                    c_type = "int"; // Default fallback
                }
            } else {
                c_type = "int"; // Default fallback for auto without initializer
            }
        } else if (type_node->type == AST_TYPE) {
            c_type = codegen_echo_type_to_c_type(type_node->value);
        }
    }
    
    // Write variable declaration with indentation
    codegen_write_indent(gen);
    codegen_write(gen, "%s %s", c_type, var_decl->value);
    
    // Handle initialization if present
    if (var_decl->child_count > 1) {
        codegen_write(gen, " = ");
        CodegenResult result = codegen_generate_expression(gen, var_decl->children[1]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write(gen, ";\n");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_return(CodeGenerator* gen, ASTNode* return_stmt) {
    if (!gen || !return_stmt || return_stmt->type != AST_RETURN) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    codegen_write_indent(gen);
    codegen_write(gen, "return");
    
    // Handle return value if present
    if (return_stmt->child_count > 0) {
        codegen_write(gen, " ");
        CodegenResult result = codegen_generate_expression(gen, return_stmt->children[0]);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write(gen, ";\n");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_if(CodeGenerator* gen, ASTNode* if_stmt) {
    if (!gen || !if_stmt || if_stmt->type != AST_IF) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (if_stmt->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate if condition with indentation
    codegen_write_indent(gen);
    return codegen_generate_if_internal(gen, if_stmt);
}

// Internal function without indentation for else-if chains
CodegenResult codegen_generate_if_internal(CodeGenerator* gen, ASTNode* if_stmt) {
    if (!gen || !if_stmt || if_stmt->type != AST_IF) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (if_stmt->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate if condition (without indentation)
    codegen_write(gen, "if (");
    
    CodegenResult result = codegen_generate_expression(gen, if_stmt->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write(gen, ") ");
    
    // Generate then block
    ASTNode* then_block = if_stmt->children[1];
    if (then_block->type == AST_BLOCK) {
        codegen_write(gen, "{\n");
        codegen_increase_indent(gen);
        
        result = codegen_generate_block(gen, then_block);
        if (result != CODEGEN_SUCCESS) return result;
        
        codegen_decrease_indent(gen);
        codegen_write_line(gen, "}");
    } else {
        // Single statement without braces
        codegen_write(gen, "\n");
        codegen_increase_indent(gen);
        
        result = codegen_generate_statement(gen, then_block);
        if (result != CODEGEN_SUCCESS) return result;
        
        codegen_decrease_indent(gen);
    }
    
    // Generate else block if present
    if (if_stmt->child_count > 2) {
        ASTNode* else_block = if_stmt->children[2];
        
        codegen_write_indent(gen);
        codegen_write(gen, "else");
        
        if (else_block->type == AST_BLOCK) {
            codegen_write(gen, " {\n");
            codegen_increase_indent(gen);
            
            result = codegen_generate_block(gen, else_block);
            if (result != CODEGEN_SUCCESS) return result;
            
            codegen_decrease_indent(gen);
            codegen_write_line(gen, "}");
        } else if (else_block->type == AST_IF) {
            // Handle else if - use internal function
            codegen_write(gen, " ");
            result = codegen_generate_if_internal(gen, else_block);
            if (result != CODEGEN_SUCCESS) return result;
        } else {
            // Single statement
            codegen_write(gen, "\n");
            codegen_increase_indent(gen);
            
            result = codegen_generate_statement(gen, else_block);
            if (result != CODEGEN_SUCCESS) return result;
            
            codegen_decrease_indent(gen);
        }
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_for(CodeGenerator* gen, ASTNode* for_stmt) {
    if (!gen || !for_stmt || for_stmt->type != AST_FOR) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    codegen_write_indent(gen);
    codegen_write(gen, "for (");
    
    int child_index = 0;
    
    // Generate init statement (optional)
    if (child_index < for_stmt->child_count && 
        for_stmt->children[child_index]->type != AST_BLOCK) {
        
        ASTNode* init = for_stmt->children[child_index];
        if (init->type == AST_VARIABLE_DECL) {
            // For variable declarations, we need to generate the type and name
            const char* c_type = "int";
            if (init->child_count > 0 && init->children[0]->type == AST_TYPE) {
                c_type = codegen_echo_type_to_c_type(init->children[0]->value);
            }
            
            codegen_write(gen, "%s %s", c_type, init->value);
            
            // Handle initialization if present
            if (init->child_count > 1) {
                codegen_write(gen, " = ");
                CodegenResult result = codegen_generate_expression(gen, init->children[1]);
                if (result != CODEGEN_SUCCESS) return result;
            }
        } else {
            // Expression statement
            CodegenResult result = codegen_generate_expression(gen, init);
            if (result != CODEGEN_SUCCESS) return result;
        }
        child_index++;
    }
    
    codegen_write(gen, "; ");
    
    // Generate condition (optional)
    if (child_index < for_stmt->child_count && 
        for_stmt->children[child_index]->type != AST_BLOCK) {
        
        CodegenResult result = codegen_generate_expression(gen, for_stmt->children[child_index]);
        if (result != CODEGEN_SUCCESS) return result;
        child_index++;
    }
    
    codegen_write(gen, "; ");
    
    // Generate increment (optional)
    if (child_index < for_stmt->child_count && 
        for_stmt->children[child_index]->type != AST_BLOCK) {
        
        CodegenResult result = codegen_generate_expression(gen, for_stmt->children[child_index]);
        if (result != CODEGEN_SUCCESS) return result;
        child_index++;
    }
    
    codegen_write(gen, ") ");
    
    // Generate body
    if (child_index < for_stmt->child_count) {
        ASTNode* body = for_stmt->children[child_index];
        
        if (body->type == AST_BLOCK) {
            codegen_write(gen, "{\n");
            codegen_increase_indent(gen);
            
            CodegenResult result = codegen_generate_block(gen, body);
            if (result != CODEGEN_SUCCESS) return result;
            
            codegen_decrease_indent(gen);
            codegen_write_line(gen, "}");
        } else {
            // Single statement
            codegen_write(gen, "\n");
            codegen_increase_indent(gen);
            
            CodegenResult result = codegen_generate_statement(gen, body);
            if (result != CODEGEN_SUCCESS) return result;
            
            codegen_decrease_indent(gen);
        }
    } else {
        // Empty body
        codegen_write(gen, "{\n");
        codegen_write_line(gen, "}");
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_while(CodeGenerator* gen, ASTNode* while_stmt) {
    if (!gen || !while_stmt || while_stmt->type != AST_WHILE) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (while_stmt->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate while condition
    codegen_write_indent(gen);
    codegen_write(gen, "while (");
    
    CodegenResult result = codegen_generate_expression(gen, while_stmt->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    codegen_write(gen, ") ");
    
    // Generate body
    ASTNode* body = while_stmt->children[1];
    if (body->type == AST_BLOCK) {
        codegen_write(gen, "{\n");
        codegen_increase_indent(gen);
        
        result = codegen_generate_block(gen, body);
        if (result != CODEGEN_SUCCESS) return result;
        
        codegen_decrease_indent(gen);
        codegen_write_line(gen, "}");
    } else {
        // Single statement
        codegen_write(gen, "\n");
        codegen_increase_indent(gen);
        
        result = codegen_generate_statement(gen, body);
        if (result != CODEGEN_SUCCESS) return result;
        
        codegen_decrease_indent(gen);
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_expression(CodeGenerator* gen, ASTNode* expr) {
    if (!gen || !expr) return CODEGEN_ERROR_INVALID_AST;
    
    switch (expr->type) {
        case AST_LITERAL:
            return codegen_generate_literal(gen, expr);
            
        case AST_IDENTIFIER:
            return codegen_generate_identifier(gen, expr);
            
        case AST_SCOPE_RESOLUTION:
            return codegen_generate_scope_resolution(gen, expr);
            
        case AST_MEMBER_ACCESS:
            return codegen_generate_member_access(gen, expr);
            
        case AST_STRUCT_LITERAL:
            return codegen_generate_struct_literal(gen, expr);
            
        case AST_BINARY_OP:
            return codegen_generate_binary_op(gen, expr);
            
        case AST_UNARY_OP:
            return codegen_generate_unary_op(gen, expr);
            
        case AST_CALL:
            return codegen_generate_call(gen, expr);
            
        case AST_ASSIGNMENT:
            return codegen_generate_assignment(gen, expr);
            
        default:
            return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
    }
}

CodegenResult codegen_generate_binary_op(CodeGenerator* gen, ASTNode* binary_op) {
    if (!gen || !binary_op || binary_op->type != AST_BINARY_OP) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (binary_op->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate left operand
    CodegenResult result = codegen_generate_expression(gen, binary_op->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate operator
    codegen_write(gen, " %s ", binary_op->value);
    
    // Generate right operand
    result = codegen_generate_expression(gen, binary_op->children[1]);
    if (result != CODEGEN_SUCCESS) return result;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_unary_op(CodeGenerator* gen, ASTNode* unary_op) {
    if (!gen || !unary_op || unary_op->type != AST_UNARY_OP) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (unary_op->child_count < 1) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate operator
    codegen_write(gen, "%s", unary_op->value);
    
    // Generate operand
    return codegen_generate_expression(gen, unary_op->children[0]);
}

CodegenResult codegen_generate_call(CodeGenerator* gen, ASTNode* call) {
    if (!gen || !call || call->type != AST_CALL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (call->child_count < 1) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    ASTNode* callee = call->children[0];
    
    // Check if this is a call to a generic function
    if (gen->type_inference && callee->type == AST_IDENTIFIER) {
        // Look up the function in symbol table
        Symbol* symbol = symbol_table_lookup(gen->symbol_table, callee->value);
        if (symbol && symbol->ast_node && symbol->ast_node->type == AST_GENERIC_FUNCTION) {
            // This is a call to a generic function
            
            // Check if this is a recursive call within a generic instantiation
            if (gen->current_generic_instantiation && 
                symbol->ast_node == gen->current_generic_instantiation->original_function) {
                // This is a recursive call - use the current instantiation's mangled name
                codegen_write(gen, "%s", gen->current_generic_instantiation->mangled_name);
            } else {
                // Find the correct instantiation
                
                // Collect argument types
                int arg_count = call->child_count - 1;
                char** arg_types = malloc(arg_count * sizeof(char*));
                if (!arg_types) return CODEGEN_ERROR_MEMORY_ALLOCATION;
                
                printf("🔍 Analyzing call to '%s' with %d arguments:\n", callee->value, arg_count);
                for (int i = 0; i < arg_count; i++) {
                    ASTNode* arg = call->children[i + 1];
                    char* raw_type = type_inference_infer_expression_type_with_symbols(gen->type_inference, arg, gen->symbol_table);
                    if (!raw_type) {
                        // Free allocated types
                        for (int j = 0; j < i; j++) {
                            free(arg_types[j]);
                        }
                        free(arg_types);
                        return CODEGEN_ERROR_INVALID_AST;
                    }
                    arg_types[i] = normalize_type_name(raw_type);
                    printf("  Arg %d: %s (raw: %s, normalized: %s)\n", i, arg->value ? arg->value : "?", raw_type, arg_types[i]);
                    free(raw_type);
                }
                
                // Find the instantiation
                GenericInstantiation* inst = type_inference_find_instantiation(
                    gen->type_inference, symbol->ast_node, arg_types, arg_count);
                
                if (inst) {
                    // Use the mangled name
                    codegen_write(gen, "%s", inst->mangled_name);
                } else {
                    // If we couldn't find instantiation by exact type match,
                    // try to find any instantiation for this function with same argument count
                    printf("⚠️ Could not find exact instantiation, searching by function name and arg count...\n");
                    
                    GenericInstantiation* fallback_inst = gen->type_inference->instantiations;
                    while (fallback_inst) {
                        if (fallback_inst->original_function == symbol->ast_node &&
                            fallback_inst->type_arg_count == arg_count) {
                            printf("✓ Using fallback instantiation: %s\n", fallback_inst->mangled_name);
                            codegen_write(gen, "%s", fallback_inst->mangled_name);
                            break;
                        }
                        fallback_inst = fallback_inst->next;
                    }
                    
                    if (!fallback_inst) {
                        // Last resort: use original name
                        printf("⚠️ No instantiation found, using original name: %s\n", callee->value);
                        codegen_write(gen, "%s", callee->value);
                    }
                }
                
                // Free argument types
                for (int i = 0; i < arg_count; i++) {
                    free(arg_types[i]);
                }
                free(arg_types);
            }
        } else {
            // Regular function call
            CodegenResult result = codegen_generate_expression(gen, callee);
            if (result != CODEGEN_SUCCESS) return result;
        }
    } else {
        // Generate function name (handles scope resolution and regular identifiers)
        CodegenResult result = codegen_generate_expression(gen, callee);
        if (result != CODEGEN_SUCCESS) return result;
    }
    
    codegen_write(gen, "(");
    
    // Generate arguments
    for (int i = 1; i < call->child_count; i++) {
        CodegenResult result = codegen_generate_expression(gen, call->children[i]);
        if (result != CODEGEN_SUCCESS) return result;
        
        if (i < call->child_count - 1) {
            codegen_write(gen, ", ");
        }
    }
    
    codegen_write(gen, ")");
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_identifier(CodeGenerator* gen, ASTNode* identifier) {
    if (!gen || !identifier || identifier->type != AST_IDENTIFIER) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    const char* name = identifier->value;
    
    // For builtin functions, try to find the symbol and use its C function name
    if (gen->symbol_table) {
        Symbol* symbol = symbol_table_lookup(gen->symbol_table, name);
        if (symbol && symbol->is_builtin && symbol->c_function_name) {
            codegen_write(gen, "%s", symbol->c_function_name);
            return CODEGEN_SUCCESS;
        }
    }
    
    // Default: use the identifier as-is (for user-defined functions and variables)
    codegen_write(gen, "%s", name);
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_literal(CodeGenerator* gen, ASTNode* literal) {
    if (!gen || !literal || literal->type != AST_LITERAL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (!literal->value) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate literal based on its type
    if (literal->data_type) {
        if (strcmp(literal->data_type, "string") == 0) {
            codegen_write(gen, "\"%s\"", literal->value);
        } else if (strcmp(literal->data_type, "char") == 0) {
            codegen_write(gen, "'%s'", literal->value);
        } else {
            // Integer, float, boolean literals
            codegen_write(gen, "%s", literal->value);
        }
    } else {
        // Default: assume it's a number or identifier
        codegen_write(gen, "%s", literal->value);
    }
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_assignment(CodeGenerator* gen, ASTNode* assignment) {
    if (!gen || !assignment || assignment->type != AST_ASSIGNMENT) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (assignment->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate left side (lvalue)
    CodegenResult result = codegen_generate_expression(gen, assignment->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate assignment operator
    codegen_write(gen, " = ");
    
    // Generate right side (rvalue)
    result = codegen_generate_expression(gen, assignment->children[1]);
    if (result != CODEGEN_SUCCESS) return result;
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_runtime_support(CodeGenerator* gen) {
    // TODO: Implement runtime support generation
    (void)gen;
    return CODEGEN_ERROR_UNSUPPORTED_FEATURE;
}

bool codegen_needs_optional_support(ASTNode* ast) {
    // TODO: Implement optional support detection
    (void)ast;
    return false;
}

bool codegen_needs_smart_pointer_support(ASTNode* ast) {
    // TODO: Implement smart pointer support detection
    (void)ast;
    return false;
}

CodegenResult codegen_generate_scope_resolution(CodeGenerator* gen, ASTNode* scope_res) {
    if (!gen || !scope_res || scope_res->type != AST_SCOPE_RESOLUTION) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (scope_res->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Build the full qualified name
    char full_name[256] = "";
    for (int i = 0; i < scope_res->child_count; i++) {
        if (i > 0) strcat(full_name, "::");
        if (scope_res->children[i]->value) {
            strcat(full_name, scope_res->children[i]->value);
        }
    }
    
    // Try to find the symbol and use its C function name
    if (gen->symbol_table) {
        Symbol* symbol = symbol_table_lookup(gen->symbol_table, full_name);
        if (symbol && symbol->is_builtin && symbol->c_function_name) {
            codegen_write(gen, "%s", symbol->c_function_name);
            return CODEGEN_SUCCESS;
        }
    }
    
    // Default: just output the qualified name (for user-defined functions)
    codegen_write(gen, "%s", full_name);
    
    return CODEGEN_SUCCESS;
}

CodegenResult codegen_generate_member_access(CodeGenerator* gen, ASTNode* member_access) {
    if (!gen || !member_access || member_access->type != AST_MEMBER_ACCESS) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    if (member_access->child_count < 2) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate left operand (object or pointer)
    CodegenResult result = codegen_generate_expression(gen, member_access->children[0]);
    if (result != CODEGEN_SUCCESS) return result;
    
    // Generate member access operator (. or ->)
    const char* operator = member_access->value;
    if (operator && strcmp(operator, ".") == 0) {
        codegen_write(gen, ".");
    } else {
        // Default to -> for pointer access
        codegen_write(gen, "->");
    }
    
    // Generate field name
    result = codegen_generate_expression(gen, member_access->children[1]);
    if (result != CODEGEN_SUCCESS) return result;
    
    return CODEGEN_SUCCESS;
}

// Generate struct definition
CodegenResult codegen_generate_struct(CodeGenerator* gen, ASTNode* struct_node) {
    if (!gen || !struct_node || struct_node->type != AST_STRUCT) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Write struct header
    codegen_write_line(gen, "typedef struct {");
    codegen_increase_indent(gen);
    
    // Generate fields
    for (int i = 0; i < struct_node->child_count; i++) {
        ASTNode* field = struct_node->children[i];
        
        if (field->type == AST_VARIABLE_DECL && field->child_count > 0) {
            ASTNode* field_type = field->children[0];
            
            if (field_type->type == AST_TYPE) {
                const char* c_type = codegen_echo_type_to_c_type(field_type->value);
                const char* field_name = field->value;
                
                // Handle pointer types
                if (field_type->is_pointer) {
                    codegen_write_line(gen, "%s* %s;", c_type, field_name);
                } else {
                    codegen_write_line(gen, "%s %s;", c_type, field_name);
                }
            }
        }
    }
    
    codegen_decrease_indent(gen);
    codegen_write_line(gen, "} %s;", struct_node->value);
    
    return CODEGEN_SUCCESS;
}

// Generate struct literal initialization
CodegenResult codegen_generate_struct_literal(CodeGenerator* gen, ASTNode* struct_literal) {
    if (!gen || !struct_literal || struct_literal->type != AST_STRUCT_LITERAL) {
        return CODEGEN_ERROR_INVALID_AST;
    }
    
    // Generate C struct literal syntax: {.field = value, .field2 = value2}
    codegen_write(gen, "{");
    
    for (int i = 0; i < struct_literal->child_count; i++) {
        ASTNode* field_init = struct_literal->children[i];
        
        if (field_init->type == AST_ASSIGNMENT && field_init->child_count >= 2) {
            ASTNode* field_name = field_init->children[0];
            ASTNode* field_value = field_init->children[1];
            
            // Generate .field_name = value
            if (field_name->type == AST_IDENTIFIER) {
                codegen_write(gen, ".%s = ", field_name->value);
                
                CodegenResult result = codegen_generate_expression(gen, field_value);
                if (result != CODEGEN_SUCCESS) return result;
                
                // Add comma if not the last field
                if (i < struct_literal->child_count - 1) {
                    codegen_write(gen, ", ");
                }
            }
        }
    }
    
    codegen_write(gen, "}");
    
    return CODEGEN_SUCCESS;
}

// ================== GENERICS SUPPORT ==================

// Generate generic instantiations declarations
CodegenResult codegen_generate_generic_instantiations(CodeGenerator* gen) {
    if (!gen || !gen->type_inference) return CODEGEN_SUCCESS;
    
    printf("Generating generic instantiation declarations...\n");
    
    GenericInstantiation* inst = gen->type_inference->instantiations;
    while (inst) {
        // Generate function signature for this instantiation
        printf("  Declaring instantiation: %s\n", inst->mangled_name);
        
        // Get return type from original function
        ASTNode* return_type_node = NULL;
        for (int i = 0; i < inst->original_function->child_count; i++) {
            if (inst->original_function->children[i]->type == AST_TYPE || 
                inst->original_function->children[i]->type == AST_AUTO_TYPE) {
                return_type_node = inst->original_function->children[i];
                break;
            }
        }
        
        const char* return_type = "void";
        if (return_type_node) {
            if (return_type_node->type == AST_AUTO_TYPE) {
                // For auto return type, use the inferred type from the last parameter type
                if (inst->type_arg_count > 0) {
                    return_type = codegen_echo_type_to_c_type(inst->type_arguments[inst->type_arg_count - 1]);
                }
            } else {
                return_type = codegen_echo_type_to_c_type(return_type_node->value);
            }
        }
        
        // Generate signature
        codegen_write(gen, "%s %s(", return_type, inst->mangled_name);
        
        // Generate parameters with concrete types
        ASTNode* params = NULL;
        for (int i = 0; i < inst->original_function->child_count; i++) {
            if (inst->original_function->children[i]->type == AST_PARAMETER) {
                params = inst->original_function->children[i];
                break;
            }
        }
        
        if (params && params->child_count > 0) {
            for (int i = 0; i < params->child_count; i++) {
                ASTNode* param = params->children[i];
                if (param->type == AST_PARAMETER && i < inst->type_arg_count) {
                    const char* param_type = codegen_echo_type_to_c_type(inst->type_arguments[i]);
                    codegen_write(gen, "%s %s", param_type, param->value);
                    
                    if (i < params->child_count - 1) {
                        codegen_write(gen, ", ");
                    }
                }
            }
        } else {
            codegen_write(gen, "void");
        }
        
        codegen_write(gen, ");\n");
        
        inst = inst->next;
    }
    
    return CODEGEN_SUCCESS;
}

// Generate generic instantiations implementations
CodegenResult codegen_generate_generic_instantiations_impl(CodeGenerator* gen) {
    if (!gen || !gen->type_inference) return CODEGEN_SUCCESS;
    
    printf("Generating generic instantiation implementations...\n");
    
    GenericInstantiation* inst = gen->type_inference->instantiations;
    while (inst) {
        printf("  Generating implementation: %s\n", inst->mangled_name);
        
        CodegenResult result = codegen_generate_instantiated_function(gen, inst);
        if (result != CODEGEN_SUCCESS) return result;
        
        codegen_write_line(gen, "");
        
        inst = inst->next;
    }
    
    return CODEGEN_SUCCESS;
}

// Generate instantiated function implementation
CodegenResult codegen_generate_instantiated_function(CodeGenerator* gen, void* inst_ptr) {
    if (!gen || !inst_ptr) return CODEGEN_ERROR_INVALID_AST;
    
    GenericInstantiation* inst = (GenericInstantiation*)inst_ptr;
    
    ASTNode* original = inst->original_function;
    
    // Generate function signature
    ASTNode* return_type_node = NULL;
    for (int i = 0; i < original->child_count; i++) {
        if (original->children[i]->type == AST_TYPE || 
            original->children[i]->type == AST_AUTO_TYPE) {
            return_type_node = original->children[i];
            break;
        }
    }
    
    const char* return_type = "void";
    if (return_type_node) {
        if (return_type_node->type == AST_AUTO_TYPE) {
            // For auto return type, use the inferred type
            if (inst->type_arg_count > 0) {
                return_type = codegen_echo_type_to_c_type(inst->type_arguments[inst->type_arg_count - 1]);
            }
        } else {
            return_type = codegen_echo_type_to_c_type(return_type_node->value);
        }
    }
    
    codegen_write(gen, "%s %s(", return_type, inst->mangled_name);
    
    // Generate parameters with concrete types
    ASTNode* params = NULL;
    for (int i = 0; i < original->child_count; i++) {
        if (original->children[i]->type == AST_PARAMETER) {
            params = original->children[i];
            break;
        }
    }
    
    if (params && params->child_count > 0) {
        for (int i = 0; i < params->child_count; i++) {
            ASTNode* param = params->children[i];
            if (param->type == AST_PARAMETER && i < inst->type_arg_count) {
                const char* param_type = codegen_echo_type_to_c_type(inst->type_arguments[i]);
                codegen_write(gen, "%s %s", param_type, param->value);
                
                if (i < params->child_count - 1) {
                    codegen_write(gen, ", ");
                }
            }
        }
    } else {
        codegen_write(gen, "void");
    }
    
    codegen_write(gen, ") {\n");
    
    // Set current generic instantiation context
    struct GenericInstantiation* prev_instantiation = gen->current_generic_instantiation;
    gen->current_generic_instantiation = inst;
    
    // Generate function body
    codegen_increase_indent(gen);
    
    ASTNode* body = NULL;
    for (int i = 0; i < original->child_count; i++) {
        if (original->children[i]->type == AST_BLOCK) {
            body = original->children[i];
            break;
        }
    }
    
    if (body) {
        // Generate body statements
        for (int i = 0; i < body->child_count; i++) {
            CodegenResult result = codegen_generate_statement(gen, body->children[i]);
            if (result != CODEGEN_SUCCESS) {
                gen->current_generic_instantiation = prev_instantiation;
                codegen_decrease_indent(gen);
                return result;
            }
        }
    }
    
    codegen_decrease_indent(gen);
    codegen_write_line(gen, "}");
    
    // Restore previous context
    gen->current_generic_instantiation = prev_instantiation;
    
    return CODEGEN_SUCCESS;
} 